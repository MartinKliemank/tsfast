#AUTOGENERATED! DO NOT EDIT! File to edit: dev/12_TensorQuaternions.ipynb (unless otherwise specified).

__all__ = ['TensorQuaternions', 'rad2deg', 'multiplyQuat', 'norm_quaternion', 'conjQuat', 'diffQuat', 'safe_acos',
           'inclinationAngle', 'relativeAngle', 'ms_inclination', 'rms_inclination_deg', 'mean_inclination_deg',
           'ms_rel_angle', 'rms_rel_angle_deg', 'mean_rel_angle_deg', 'QuaternionRegularizer',
           'plot_quaternions_single_figure', 'plot_quaternions_multi_figures']

#Cell
from .core import *
from .model import *
from .learner import *
from fastai2.basics import *
from fastai2.callback.progress import *
from fastai2.callback.schedule import *

#Cell
class TensorQuaternions(TensorSequences): pass

#Cell
_pi = torch.Tensor([3.14159265358979323846])
def rad2deg(t):
    return 180. * t / _pi.to(t.device).type(t.dtype)

#Cell
def multiplyQuat(q1, q2):
    """quat1*quat2"""
    output = torch.zeros_like(q1)
    output[..., 0] = q1[..., 0] * q2[..., 0] - q1[..., 1] * q2[..., 1] - q1[..., 2] * q2[..., 2] - q1[..., 3] * q2[..., 3]
    output[..., 1] = q1[..., 0] * q2[..., 1] + q1[..., 1] * q2[..., 0] + q1[..., 2] * q2[..., 3] - q1[..., 3] * q2[..., 2]
    output[..., 2] = q1[..., 0] * q2[..., 2] - q1[..., 1] * q2[..., 3] + q1[..., 2] * q2[..., 0] + q1[..., 3] * q2[..., 1]
    output[..., 3] = q1[..., 0] * q2[..., 3] + q1[..., 1] * q2[..., 2] - q1[..., 2] * q2[..., 1] + q1[..., 3] * q2[..., 0]
    return output

#Cell
def norm_quaternion(q):
    return q / q.norm(dim=-1)[...,None]

#Cell
_conjugate_quaternion = tensor([1,-1,-1,-1])
def conjQuat(q):
    return q * _conjugate_quaternion.to(q.device).type(q.dtype)

#Cell
def diffQuat(q1,q2,norm=True):
    if norm:
        nq1 = norm_quaternion(q1)
        nq2 = norm_quaternion(q2)
    else:
        nq1 = q1
        nq2 = q2
    return multiplyQuat(nq1, conjQuat(nq2))

#Cell
def safe_acos(t):
    '''numericaly stable variant of arcuscosine'''
    eps = 3e-8 #minimum value for acos(1) != 0
    return t.clamp(-1.0 + eps, 1.0 - eps).acos()

#Cell
def inclinationAngle(q1,q2):
    q = diffQuat(q1,q2)
    return 2*safe_acos((q[..., 3]**2 + q[..., 0]**2).sqrt())

def relativeAngle(q1,q2):
    q = diffQuat(q1,q2)
    return 2*safe_acos((q[..., 0]).abs())

#Cell
def ms_inclination(q1,q2):
    inclination = inclinationAngle(q1,q2)
    return  (inclination**2).mean()

#Cell
def rms_inclination_deg(q1,q2):
    inclination = inclinationAngle(q1,q2)
    return  rad2deg((inclination**2).mean().sqrt())

#Cell
def mean_inclination_deg(q1,q2):
    inclination = inclinationAngle(q1,q2)
    return  rad2deg(inclination.mean())

#Cell
def ms_rel_angle(q1,q2):
    rel_angle = relativeAngle(q1,q2)
    return  (rel_angle**2).mean()

#Cell
def rms_rel_angle_deg(q1,q2):
    rel_angle = relativeAngle(q1,q2)
    return  rad2deg((rel_angle**2).mean().sqrt())

#Cell
def mean_rel_angle_deg(q1,q2):
    rel_angle = relativeAngle(q1,q2)
    return  rad2deg(rel_angle.mean())

#Cell
from fastai2.callback.hook import *
@delegates()
class QuaternionRegularizer(HookCallback):
    "Callback that adds AR and TAR to the loss, calculated by output of provided layer"
    run_before=TrainEvalCallback
    def __init__(self,reg_unit=0.0,detach=False, **kwargs):
        super().__init__(detach=detach,**kwargs)
        store_attr(self,'reg_unit')

    def hook(self, m, i, o):
        if type(o) is torch.Tensor:
            self.out = o
        else:
            self.out = o[0]

    def after_loss(self):
        if not self.training: return
        h = self.out.float()

        if self.reg_unit != 0.:
            l_a = float(self.reg_unit) * ((1-h.norm(dim=-1))**2).mean()
#             import pdb; pdb.set_trace()
            self.learn.loss += l_a

#Cell
def plot_quaternions_single_figure(n_samples,samples,outs):
    rows=max(1,((n_samples-1) // 3)+1)
    cols=min(3,n_samples)
    fig = plt.figure(figsize=(9,2*cols))
    outer_grid = fig.add_gridspec(rows, cols)
#     import pdb; pdb.set_trace()
    n_targ = 1
    for i in range(n_samples):
        in_signals = samples[i][0]
        targ_signals = samples[i][1]
        out_signals = outs[i][0]
        inner_grid = outer_grid[i].subgridspec(n_targ+1, 1)
        ax = fig.add_subplot(inner_grid[0])
        ax.plot(rad2deg(inclinationAngle(out_signals,targ_signals)))
        ax.label_outer()

        ax = fig.add_subplot(inner_grid[1])
        ax.plot(in_signals)
    plt.tight_layout()


#Cell
def plot_quaternions_multi_figures(n_samples,samples,outs=None):
    n_targ = 1
    for i in range(n_samples):
        fig = plt.figure(figsize=(9,3))
        axs = fig.subplots(nrows=n_targ+1,sharex=True)
        in_signals = samples[i][0]
        targ_signals = samples[i][1]
        out_signals = outs[i][0]
        ax = axs[0]
        ax.plot(rad2deg(inclinationAngle(out_signals,targ_signals)))

        axs[-1].plot(in_signals)
        plt.tight_layout()

#Cell
@typedispatch
def show_results(x:TensorSequences, y:TensorQuaternions, samples, outs, ctxs=None, max_n=2, **kwargs):
    n_samples = min(len(samples), max_n)
#     import pdb; pdb.set_trace()
    if n_samples > 3:
        #if there are more then 3 samples to plot then put them in a single figure
        plot_quaternions_single_figure(n_samples,samples,outs)
    else:
        #if there are less then 3 samples to plot then put each in its own figure
        plot_quaternions_multi_figures(n_samples,samples,outs)
    return ctxs