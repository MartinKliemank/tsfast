#AUTOGENERATED! DO NOT EDIT! File to edit: dev/00_core.ipynb (unless otherwise specified).

__all__ = ['hdf2sequence', 'hdf2scalars', 'Hdf2SeqSeq', 'Hdf2SeqScal', 'SequenceItem', 'SeqTfm', 'createWindows']

#Cell
from fastai2.data.all import *
import h5py

#Cell
def hdf2sequence(hdf_path,c_names):
    with h5py.File(hdf_path,'r') as f:
#         import pdb; pdb.set_trace()
        l_array = [f[n][:][:,None] for n in c_names]
        seq = np.concatenate(l_array,axis=1)
        return seq

#Cell
def hdf2scalars(hdf_path,c_names):
    with h5py.File(hdf_path,'r') as f:
#         import pdb; pdb.set_trace()
#         l_array = [f[n][:][:,None] for n in c_names]
#         seq = np.concatenate(l_array,axis=1)
        return None

#Cell
class Hdf2SeqSeq(Transform):
    def __init__(self, seq_inp,scal_inp, seq_out): self.seq_inp,self.scal_inp,self.seq_out = seq_inp,scal_inp,seq_out
    def encodes(self, o): return (hdf2sequence(o,self.seq_inp),
                                  hdf2scalars(o,self.scal_inp),
                                  hdf2sequence(o,self.seq_out))
    def decodes(self, x): return SequenceItem(x)

class Hdf2SeqScal(Transform):
    def __init__(self, seq_inp,scal_inp, scal_out): self.seq_inp,self.scal_inp,self.scal_out = seq_inp,scal_inp,scal_out
    def encodes(self, o): return (hdf2sequence(o,self.seq_inp),
                                  hdf2scalars(o,self.scal_inp),
                                  hdf2scalars(o,self.scal_out))
    def decodes(self, x): return SequenceItem(x)

#Cell

#TODO: Pruefen ob Zielgroesse 'self[2]' sequenz ist
class SequenceItem(Tuple):
    def show(self, ctx=None, **kwargs):
        plt.figure()
        plt.plot(self[2])

#Cell
class SeqTfm(Transform):
    def decodes(self, x): return SequenceItem(x)

#Cell

def createWindows(x):
    win_size = 100
    x_seq = x[0]
    n_win = x_seq.shape[0]//win_size
    win_list = [x]*n_win
    for i,win in enumerate(win_list):
        win_list[i]=(
            win[0][i*win_size:(i+1)*win_size],
            win[1],
            win[2][i*win_size:(i+1)*win_size])
    return L(win_list)