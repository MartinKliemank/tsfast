#AUTOGENERATED! DO NOT EDIT! File to edit: dev/00_core.ipynb (unless otherwise specified).

__all__ = ['get_hdf_files', 'hdf_extensions', 'hdf2sequence', 'hdf2scalars', 'Hdf2SeqSeq', 'Hdf2SeqScal',
           'Hdf2SeqScalSeq', 'Hdf2SeqScalScal', 'SequenceItem', 'SeqTfm', 'ParentSplitter', 'createWindows']

#Cell
from fastai2.data.all import *
import h5py

#Cell
hdf_extensions = ['.hdf5']
def get_hdf_files(path,recurse=True, folders=None):
    "Get hdf5 files in `path` recursively, only in `folders`, if specified."
    return get_files(path, extensions=hdf_extensions, recurse=recurse, folders=folders)

#Cell
def hdf2sequence(hdf_path,c_names):
    with h5py.File(hdf_path,'r') as f:
#         import pdb; pdb.set_trace()
        l_array = [f[n][:][:,None] for n in c_names]
        seq = np.concatenate(l_array,axis=1)
        return seq

#Cell
def hdf2scalars(hdf_path,c_names):
    with h5py.File(hdf_path,'r') as f:
#         import pdb; pdb.set_trace()
#         l_array = [f[n][:][:,None] for n in c_names]
#         seq = np.concatenate(l_array,axis=1)
        return None

#Cell
class Hdf2SeqSeq(Transform):
    def __init__(self, seq_inp, seq_out): self.seq_inp,self.seq_out = seq_inp,seq_out
    def encodes(self, o): return (hdf2sequence(o,self.seq_inp),
                                  hdf2sequence(o,self.seq_out))
    def decodes(self, x): return SequenceItem(x)

class Hdf2SeqScal(Transform):
    def __init__(self, seq_inp, scal_out): self.seq_inp,self.scal_out = seq_inp,scal_out
    def encodes(self, o): return (hdf2sequence(o,self.seq_inp),
                                  hdf2scalars(o,self.scal_out))
    def decodes(self, x): return SequenceItem(x)
class Hdf2SeqScalSeq(Transform):
    def __init__(self, seq_inp,scal_inp, seq_out): self.seq_inp,self.scal_inp,self.seq_out = seq_inp,scal_inp,seq_out
    def encodes(self, o): return (hdf2sequence(o,self.seq_inp),
                                  hdf2scalars(o,self.scal_inp),
                                  hdf2sequence(o,self.seq_out))
    def decodes(self, x): return SequenceItem(x)

class Hdf2SeqScalScal(Transform):
    def __init__(self, seq_inp,scal_inp, scal_out): self.seq_inp,self.scal_inp,self.scal_out = seq_inp,scal_inp,scal_out
    def encodes(self, o): return (hdf2sequence(o,self.seq_inp),
                                  hdf2scalars(o,self.scal_inp),
                                  hdf2scalars(o,self.scal_out))
    def decodes(self, x): return SequenceItem(x)

#Cell

#TODO: Fallunterscheidung der Sequenzen
class SequenceItem(Tuple):
    def show(self, ctx=None, **kwargs):
        plt.figure()
        plt.plot(self[2])

#Cell
class SeqTfm(Transform):
    def decodes(self, x): return SequenceItem(x)

#Cell
def _parent_idxs(items, name): return mask2idxs(Path(o).parent.name == name for o in items)

def ParentSplitter(train_name='train', valid_name='valid'):
    "Split `items` from the parent folder names (`train_name` and `valid_name`)."
    def _inner(o, **kwargs):
        return _parent_idxs(o, train_name),_parent_idxs(o, valid_name)
    return _inner

#Cell

def createWindows(x):
    win_size = 100
    x_seq = x[0]
    n_win = x_seq.shape[0]//win_size
    win_list = [x]*n_win
    for i,win in enumerate(win_list):
        win_list[i]=(
            win[0][i*win_size:(i+1)*win_size],
            win[1][i*win_size:(i+1)*win_size])
    return L(win_list)